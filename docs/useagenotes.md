# Installation
* The system has currently been tested on Raspberry Pi Zero, Pi Zero W, 2, and 3 using an Adafruit 3.5" resistive PiTFT, Official Raspberry Pi 7" Capacitive Touchscreen, Adafruit 2.8" capacitive PiTFT, and a Waveshare 3.5" screen.  Note that some screens support dimming (the Adafruit ones for example) but some don't (the Waveshare).  Some limited testing has been done on Chinese clone screens - no guarantees there as you may have to work on their calibrations.  To set up a system use one of the following methods:
    * Easiest:  Build your Pi using the a recent Raspbian image from the Foundation.  The system has been tested and run on Jessie and Stretch versions.  (As of 8/29/2017 the current version is a Stretch version.)  Add the **pisetup.sh** script to the /boot partition on the SD card while you have the card in whatever system you use to write the image.  After booting the Pi with this image you may want to configure WiFi from the console if you need that.  Then run as root `bash /boot/pisetup.sh`.  
        * Note: Various subscripts get run by pisetup some of which may give the option of rebooting the system.  *DO NOT REBOOT* from these subscripts.  You should manually reboot only after the entire pisetup script finishes and you haven't asked to continue install (see below).  If you answer y to the continue install question then you should have to answer a few questions at the start and then nothing more until the very end where you can set up a minimal test case.

        This script will ask questions needed to configure the console hardware and software:
        * A node name: allows the node to be addressed by name on the network versus only by it's IP address.  Set this and make sure it is unique on your network.  You should be able to address the node later as <nodename>.local.
        * VNC Standard Port: this allows you to move the VNC server and ssh server to non-standard ports if you wish.  If you answer yes a VNC port will be established on 5900 for the console and on 5901 for a virtual console and ssh will run on 22.  If you supply a port number here then the VNC virtual console will appear on that port, the VNC console will appear on that port minus 1, and ssh will appear on that port minus 100.  Don't use this unless you know why you are - one reason might be if you are planning to open a firewall in your router to allow non-local access to the console (often but not always a bad idea).  To access the node via VNC you will probably want to normally use the virtual VNC since the console VNC will have the size and shape of your Pi screen and will only display an interactive terminal if the pi screen is showing one (i.e., the softconsole is not running).
        * Personal: You probably want to answer N to this.  I sometimes run special stable versions of the softconsole at my house to try out things.  Setting this to yes will access such versions which may mean you get something that isn't tested for your situation.
        * Autostart: Normally you'll answer y to this as it sets things up to automatically run the softconsole on the pi screen at boot rather than leaving your pi at an X-window session.
        * Screen type: Enter the type of pi screen you are using from the list of supported ones in the question.  Other screens may well work but you'll need to install them yourself after this script finishes.
        * Whether you want to set up a minimal test. (see below)
        * Continue install: answer yes here to simplify the install process.  The system will automatically reboot and run the second part of the softconsole install. 
 If you don't answer y then when the script finishes you should reboot and then run **installconsole.sh** as root after the reboot.  Before rebooting you may do any other system configuration that you need.  For example, this is where you'd configure a screen type that isn't (yet) supported by the setup script.
   
        * **Note**: There are some long pauses in my experience doing this.  When you first boot Stretch, e.g., it may seem to give you a prompt and then blank the screen.  It stays blank a long time (3-4 minutes) and then opens a graphical console.  There are also some long downloads and unpacks.  Particularly if you are installing on a Pi0 be patient - that little processor is working as hard as it can!
    * Expert alternative: Configure its networking and expand its file system.  Manually examine the scripts above to perform the specific configurations and installations that make sense for your system.
* Note: I don't suggest setting the personal system flag in the install script.  What it does is force the update function of the console to use the release I am running on my home systems.  Generally this is fine since I don't want my house system broken, but may be a less tested version.    
* The resultant system should have a consolestable and consolebeta directories populated and a Console directory created.  The config.txt goes in the Console directory.  Run the console as "sudo python -u console.py" from within the consolestable directory.  I also arrange to run the console automatically at boot.  An example of this is in the rc.local file in the scripts directory. My script will run the stable version unless a "usebeta" file and a "cleanexit" file exist in the home directory.  From the maintenance screen in console you can ask to set the beta version and download the current beta.  If you set the beta version and you shutdown the console cleanly the beta will run else it will fall back to the stable version.
* Current release notes:
    * Version 2 code made a major overhaul the the fundamental program sequencing structure to allow for alert procedures and alert screens.  Alert procedures are procedures that can be called based on time, the value of an ISY var, or the state of an ISY device.  Alert screens are screens that can be defined to take over control of the display based on the value of an ISY var or an ISY node value, possibly delayed in time by some period.  Alert screens can be deferred by a keytouch or can execute some action that will resolve the alert.  If the alert condition is otherwise cleared within the ISY, the screen will also go away.
    * Note that all the source code for the console is available on github under kevinkahn/softconsole and you are free to examine and/or modify as you like.

# Console Directory and Files
The installation creates a number of diretories and installs many files, all based in the /home/pi directory.  First there 3 directories that my hold the actual program and its documentation.  The directory **consolestable** holds the current released code.  If you later update the release via the maintenance screen or via an automatic update procedure the files in this directory get updated.  The directory **consolebeta** holds the current beta release.  Normally you won't care about or run this version since it is test code.  You can select to run this version from the console maintenance screen but I don't suggest you do that unless you are doing because I asked you to.  The directory **consolerem** is empty and is an artifact of my debugging and test environment.  The directory **Console** is the only directory that you should normally have reason to manually change or use.  It holds, by default, the configuration files and the operational log files for the console.  There are 2 log files left in /home/pi from the installation process, earlyprep.log and prep.log.  These may be useful for diagnosing issues if a problem occurs during system installation.  The file text.txt is a log of extra library installs that my happen during the upgrade of an existing system, again for diagnostic purposes.  The python script **adafruit-pitft-touch-cal** is used during installation to set up the screen calibration.  It is left behind in case any issues arise with that. Finally the file log.txt simply records console code installs and restarts.  The contents of the 2 source directories is simply a clone of the relevant versions of the GitHub repository, although once the console has run python also leaves compiled files here.

The **Console** directory holds the log files from each run of the console.  Most recent is Console.log, previous is Console.log.1, etc.  The number of logs kept is a console parameter.  The setupconsole asks whether to set up a minimal test system.  If you answer 'n' then the Console directory is left empty and you should proceed to create your configuration information manually.  If you are just starting, you should probably answer 'y'.  In this case, a set of example configuration files will be copied from the example directory in consolestable to Console.  By default the console looks for ~/Console/config.txt as its starting configuration file.  I have for neatness used the subdirectory cfglib as a place to place additional configuration files that may be included via directives in config.txt and have conventionally use the cfg extension for these.  Note, there is no difference between the config.txt format and the cfg file formats and were I to do this again I'd probably have made them all names *.cfg.  In my use, I have found that I often what to use the same screen on a number of my consoles and this allows me to create those screen configurations once and copy them to each system.  Se the next section for a suggested way to get started via the minimal configuration file that is in the examples.

# Quick Setup of Minimal Test
To insure that the basic setup of the Console is ok and that you understand the pieces, there is a minimal test configuration that you might want to run.  If you answer 'y' to the question above about creating a minimal test configuration, setup will continue by asking for the IP address of your ISY, your ISY username, and your ISY password.  It will create the file Console/cfglib/auth.cfg using this information.  It will also ask for the ISY name of a single switch that you want to use for the test.  It will use this information to create a single screen with a single button that should turn that switch on and off.  It will also define a clock screen that should appear when the console is idle.

Now start the console as root by going to the consolestable directory and running python -u console.py.  This should bring up a very simple 1 screen instance of the console that can turn on/off the switch you picked.  If you leave the screen untouched for 15 seconds it should dim and then after another 30 seconds it will switch to display a cover screen - here the clock.  

You can also touch a nav key at the bottom of the screen to move to the next or previous screen in the chain (here there is only one - the clock screen) to get the clock displayed.  As this is a live screen and not a cover screen it will have nav keys.  Now if you don't touch the screen it will dim after 15 seconds, persist as a dim clock for 30 seconds and then change to a dim home screen (here the test screen), persist for 30 seconds as a dim home screen, then switch to a cover screen (here the clock also but with no nav keys).  At any point where the screen is dim touching it will brighten it, and if it is on a cover screen return you to the home screen.

Playing with this test should give a basic idea of the operation when many screens are available.  The times above are all parameters in the config file.  Multiple cover screens can be defined which will then cycle using the times in the idle list times parameter.  When the screen is "bright" touching it 3 times will switch to a Secondary chain of screens (see other example files as not such secondary chain is defined in the  minimal test).  Touching the screen 5 times will get you to the Maintenance screen from which new versions can be downloaded or the console or the Pi restarted or shutdown.
# Basic Operation/Arrangement of the Console
The basic command structure of the console is based on screens.  The program allows a main sequence of screen within which you can move forward and back via the navigation keys at the bottom of the screen.  The program also allows the definition of a secondary chain of screens.  You can move between these chains via 3 quick taps.  The reason for the 2 chains is that I have found that for any console instance it is likely to be convenient for have a few screens that get frequently accessed.  However, you may want to have many more, e.g., to include ones that control all other parts of your house.  It is annoying if these are in the main chain since you then would have to click through them all the time.  One of the screens on the main chain is designated home and this is the screen that the console will return to on its own if left idle for a timeout period.  The console also defines "cover" or idle screens which appear when the console has been idle for a while.  If more than one is defined the console will sequence through these screens based on timers.  Think of these as "covering" the home screen; they allow easy display of things like time or weather (or eventually perhaps other information).  These are passive screens when displayed with no navigation keys.  Touching them simply reverts the console to the home screen.  As a side note 5 taps will take you to a maintenance screen that allows some administrative operations.
# Setting up and Running Softconsole
First I admit in advance that the syntax and parsing of the config files is both a bit arcane and somewhat error prone.  This is larglely due to the configuration parser I use and perhaps someday I can improve this.  You've been warned!  Given an understanding for the minimal test above you can then create real configuration files as you wish:
* Create a main config file, see the files in the "example configs" directory within consolestable for help.  The name of the config file defaults first to **config.txt**.  If no config.txt file is found in the Console directory then the console looks for a file with the name **config-\<nodename\>.txt**.  This is convenient if you are running multiple consoles around your home.  You can create a single directory of all your configs and blindly load it onto each system and the system will select the correct configuration based on its name.  The basic structure of the file is a sequence of sections started with \[section name] where the outermost part of the file is implicitly a section.  Subsections which are currently only used to describe keys are started within a section with \[\[subsection]].  Within any section are parameter assignments of the form name = value.  A complete list of current parameters is found in the params.txt file in this directory.  It lists the global parameters with their type and default value if no assignment is supplied.  It also lists for each module the local parameters of that module as well as any global parameters that can be overridden in that module.  Strings may be written without quotes.
  * While error checking is limited for the config information, the program will log to the Console.log file any parameters that appear in your configuration that are not actually consumed by the console as meaningful.  This helps locate possible typos in the config file.
  * One note of importance: labels are lists of strings and should always be notated as "str1","str2".  A label with a single string must be made a list by appending a trailing comma.  Failure to do this will result in the string itself being viewed as a list of single characters which will result in strange output.
* The parameter MainChain provides the names in order of the screens accessible normally.  The parameter SecondaryChain provides a list of screens that are accessible indirectly (see below).  Any number of screens can be defined.
* Whenever a color needs to be specified you can use any color name from the W3C list at http://www.w3.org/TR/SVG11/types.html#ColorKeywords
* The config file supports an "include = filename" parameter to allow breaking it up conveniently.  This cam be useful if multiple consoles use some of the same screens and you want to have only one version of the description for those shared screens.  It also supports a "cfglib = dirname" as a default place to look for included config files.  Personally I have lots of small config files that I keep in a directory and specialize a single top level config file for each of my consoles.  See the directory "example configs" on github for lots of examples.
* Some responses from weatherunderground are fairly long phrases that don't display nicely on the weather screens.  There is a file termshorten list which is a json representation of a Python dictionary that maps phrases to shorter ones for display.  It is self explanatory if you look at the examples that are prepopulated.  You can edit this as you wish to add or change phrases to be shortened.

# Currently supported screens
* Keypad: mimics the KPL.  Can support any number of buttons from 1 to 25 and will autoplace/autosize buttons in this range.  Parmetrs KeysPerColumn and KeysPerRow may be used to override the auto placement of the keys.  Keys may be colored as desired.  Key types are:
    * ONOFF: linked to a device or scene and supports On, Off, FastOn, FastOff behaviors
    * RUNPROG: linked to a program to run.  It issues a RunThen on the designated program.  It supports the following modifier parameters:    
    * (Deprecated-use RUNPROG with modifiers) ONBLINKRUNTHEN: linked to a program.  Will blink to provide user feedback and will issue RunThen on program
    * ON: will always send an "on" command to the linked device.  This is useful for things like garage doors that use on toggles.
    * OFF: will always send an "off" command to the linked device.
    * SETVAR: set the value of an ISY variable
    * Modifier Parameters: The ONOFF and RUNPROG keytypes support certain parameters that modify the key behavior:
        * Verify = 1: displays a confirmation screen before running the program.  The messages on the confirmation screen can be customized with the GoMsg and/or NoGoMsg parameters.
        * Blink = n: provide visual feedback when when the runthen is issued by blinking the key n times.
        * FastPress = 1: requires a quick double tap to activate the key. (Note not applicable to the ONOFF keys since there a double press corresponds to issuing a fast on or off to the device).
     
    * Note: for scenes ONOFF will choose a device to use as a proxy for the state of the scene for purposes of the appearance of the button.  Generally this will turn out to be some other switch or KPL button that is a controller for the scene.  This can be overridden by supplying a specific device address or name to use as the proxy.
* Clock: displays a clock formatted according to the OutFormat parameter using any of the underlying OS time formatting codes.  The character size for each line can be set individually.  If there are more lines in the format than character sizes the last size is repeated. Python standard formatting is at https://docs.python.org/2/library/time.html.  Linux (RPi) supports a somewhat richer set of codes e.g. http://linux.die.net/man/3/strftime
* Weather: uses Weather Underground to display current conditions and forecast.  The location parameter is a WU location code - see their site for codes.  To use this screen you must have a WU key which can be gotten for free for low volume use.  
* Thermostat: mimics the front panel of the Insteon thermostat and provides full function equivalency.
* Time/Temp: combined screen, nice as a sleep screen that gives current time and the weather at a single location.  Format of the screen is largely controlled by the config.txt file.
* Alert: used to display an alarm condition - see below.

# Alerts
Alerts are defined in an "\[Alerts\]" section of the config files.  See cfglib/pdxalerts for some examples.  Currently alerts can be triggered periodically, based on a node state chance, or based on a variable state change.  The effect of the alert can be delayed by some time to avoid alerts for routine events that should clear within some typical window.  Alerts can either invoke an alert screen (see the away and garage alerts in the sample file) or an alert procedure (see the update alert).
## Triggers
The condition that causes an alert is defined within the config section that defines the alert.  It has a **Type** which is currently Periodic, StateVarChange, IntVarChange, or NodeChange.  For the *var* triggers Var, VarType, Test, and Value are used to describe the variable and how to test it.  For the *node* trigger Node, Test, and Value describe the trigger.  For *periodic*, Interval describes the period.  For any of the triggers a Delay parameter may be specified to have the actual triggering delays some time period beyond the condition becoming true.
Triggers cause either an alert screen to be shown or an alert proc to be run.  If the screen or proc in question takes some parameter from the alert the Parameter defines it (see NetworkHealth for example).
## Local Variables
It is possible to define variables local to the console by creating a **[[Variables]]** section in the config file and defining one or more **varname = \<value\>** within it.  These may be used in triggers etc. and set in alert procedures or by a SETVAR key.  At the moment they have limited but some use.
## Alert Procedures
Currently the following alerts are available:
* **autoversion:** trigger this either at init time or periodically to check github for a new release.  If a new *currentrelease* is found it is downloaded, installed, and the console rebooted with the new version.  The old version is moved to a directory under the consolestable called *previousversion*.
* **netcmd:** if the ISY has an integer variable defined with a name Command.\<nodename\> then a capability is enabled to issue a command on the console by changing the value of the ISY variable.  (To conform with ISY variable naming rules and '-' characters in the node name are replaced by '.' in the variable name.) To see the available commands that can be remotely issued see the header of the netcmd.py file in the source code.
* **networkhealth** when triggered (typically periodically)check for network connectivity to a specified IP address.  E.g., checking for 8.8.8.8 (the google name servers) will allow creation of an alert if Internet access is lost.  Typically this trigger will be used to invoke an alert screen to display the alarm.  Define the trigger to have Parameter = IPaddress,localvarname and localvarname will be set to 1 if the address is pingable and 0 otherwise.  If the variable changes it triggers any alert based on a "varchange" which can be used to display the alarm.
* **temptoisy** when triggered (typically periodically) copy a value from a WeatherUnderground station to an ISY variable. In the alert devfine Invoke = GetTempsToISY.SendTemps amd the Parameter to describe the field and target variable.  Parameter = <station>, <transferstring> where station is a location code from WU and transferstring is a sequence of alternating field names and variable names separated by spaces.  The field names are "typecode:name" where typecode is C for current reading and F for current forecase.  The variable names are "type:name" where type is S for state, I for integer, and L for local variable.  and example parameter string might be something like:
        Parameter = KPDX,  C:Temp S:TempPDX F:Low S:ForecastLowPDX
## Alert Screens
These are screens that are triggered to appear based on a node or variable state, perhaps with a delay from the time of the state change.  E.g., display alert screen 5 minutes after garage door is opened if it is still open.  They provide a single button that can be linked to resolve the alert condition.  They are triggered by a test in the alert section of the config file defined above. An Alert screen can be deferred for a predefined time after which they will reappear. If the condition causing the alert clears they will disappear.
# Connecting Console Names with ISY Names
* Some names in the config file are used to link console objects to ISY nodes/scenes.  Specifically the section name of a thermostat sceen is used to connect that screen to an ISY thermostat and the subsection names of ONOFF keys are used to link those keys to an ISY device or scene.
* When a name is looked up in the ISY for linking preference it always given to finding the name as a scene first.  Thus if a device and a scene have the same name the console will link to the scene.
* A current limitation of the console is that names of scenes or devices in the ISY are assumed to be unique.  I.e. names qualified with folder paths are not used.  This limit may be removed in the future.

# Operating Softconsole
* Single tap on an On/Off key to actuate it
* Double tap on a program key to actuate it.  This is done to lessen accidental running of programs from random screen taps.
* Change screens via the command buttons at the bottom of the screen
* Triple tap to access the secondary chain of screens 
* 5-tap to access a maintenance screen
* After the designated time screen will dim
* After the designated time screen will automatically return to the home screen (except from the maintenance screen)
* From the home screen after the dim time out the screen will go to a "sleep" screen if designated - any tap will awaken it
    * The original version had only a single idle screen named by the DimHomeScreenCoverName parameter.  This parameter is deprecated but will still work if you don't opt for the new multi-idle screen ability.  You can designate a sequence of idle screens with DimIdleListNames and corresponding linger times per screen with DimIdleListTimes.  Once the console is idle it will cycle through these screens until tapped.  This got added to make a wall unit a nicer info display when not otherwise being used.
* On the maintenance/log screen single tap the lower part of the screen to see the next page or the upper part to see the previous page.

# Developers Notes
## Defining New Screens by Coding a Module (updated for version 2)
New screens can be developed/deployed by subclassing screen.ScreenDesc and placing the code in the screens directory.  Screens modules have a single line of code at the module level of the form "config.screentypes[*name*] = *classname*" where *name* is the string to be used in config files to as the type value to create instances and *classname* is the name of the class defined in the module.  A screen class defines the following methods (ScreenDesc provide base level implementations that should be called if overridden):

* __init__: Create a screen object based on an entry in the config file with a type equal to the type string registered in the definition of the screen.
* InitDisplay(nav): code to display the screen.  nav are the navigation keys or None and should be passed through the the underlying InitDisplay of ScreenDesc
* ReInitDisplay: code to redisplay the screen if it has been removed temporarily and assumes nav keys are already set.  Generally not overridden.
* ISYEvent(node,value): A watched ISY *node* has changed to the new *value*
* ExitScreen: code that is called as the screen is being taken off the display

## Defining New Alert Procs
Alert procs are defined as methods in classes stored in the alerts directory.  They have a single module level line of code of the form "config.alertprocs["*classname*"] = *classname*" where *classname* is the name of the class defined in the module.  The class will be instantiated once at console start time.  It may define one or more methods that will be called based on the definition of Alerts in the config file that the console reads.

## Attribute Use and Classes
The file classstruct.txt in docs provides an automatically generated list of Classes, their subclasses, and the attributes defined at each level of the class structure.  This may be a useful aid if a new screen is being written or new types of keys need to be created.

